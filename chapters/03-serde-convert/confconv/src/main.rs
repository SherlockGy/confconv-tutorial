//! confconv - 配置文件格式转换工具
//!
//! 第 3 章：引入 Serde，实现真正的格式转换
//!
//! ## 本章新增
//! - 拆分为多个模块（main.rs + convert.rs）
//! - 使用 serde 生态实现格式转换
//! - 真正可用的转换功能

// ============================================================================
// 模块声明
// ============================================================================

// mod 关键字声明一个模块
// Rust 会寻找 src/convert.rs 或 src/convert/mod.rs
mod convert;

// ============================================================================
// 导入
// ============================================================================

use clap::Parser;
// 从 convert 模块导入需要的类型和函数
// 这需要 convert.rs 中相应的项被标记为 pub
use convert::{convert, Format};
use std::fs;

// ============================================================================
// CLI 结构体定义
// ============================================================================

/// 配置文件格式转换工具
///
/// 支持在 JSON、YAML、TOML 之间互相转换
#[derive(Parser)]
#[command(name = "confconv")]
#[command(version = "0.1.0")]
#[command(about = "配置文件格式转换工具")]
struct Cli {
    /// 输入文件路径
    ///
    /// 支持 .json, .yaml, .yml, .toml 扩展名
    input: String,

    /// 输出文件路径
    ///
    /// 不指定则输出到标准输出（stdout）
    #[arg(short, long)]
    output: Option<String>,

    /// 目标格式 (json/yaml/toml)
    #[arg(short = 't', long = "to", default_value = "json")]
    format: String,

    /// 美化输出（带缩进和换行）
    #[arg(short, long)]
    pretty: bool,

    /// 显示详细信息
    #[arg(short, long)]
    verbose: bool,
}

// ============================================================================
// 程序入口
// ============================================================================

fn main() {
    let cli = Cli::parse();

    // ------------------------------------------------------------------------
    // 解析目标格式
    // ------------------------------------------------------------------------
    let to_format = match Format::from_str(&cli.format) {
        Some(f) => f,
        None => {
            // eprintln! 输出到标准错误（stderr）
            // 这是 CLI 程序的约定：错误信息输出到 stderr
            eprintln!("错误: 不支持的目标格式 '{}'", cli.format);
            eprintln!("支持的格式: json, yaml, toml");
            // 非零退出码表示程序执行失败
            std::process::exit(1);
        }
    };

    // ------------------------------------------------------------------------
    // 从文件扩展名推断源格式
    // ------------------------------------------------------------------------
    let from_format = match Format::from_extension(&cli.input) {
        Some(f) => f,
        None => {
            eprintln!("错误: 无法从文件扩展名推断格式: {}", cli.input);
            eprintln!("请使用 .json, .yaml, .yml, 或 .toml 扩展名");
            std::process::exit(1);
        }
    };

    // 详细模式下打印格式信息
    if cli.verbose {
        println!("源格式: {:?}", from_format);
        println!("目标格式: {:?}", to_format);
    }

    // ------------------------------------------------------------------------
    // 读取输入文件
    // ------------------------------------------------------------------------
    // fs::read_to_string 读取整个文件到字符串
    // 对于配置文件通常不会很大，这种方式简单且够用
    let input_content = match fs::read_to_string(&cli.input) {
        Ok(content) => content,
        Err(e) => {
            eprintln!("错误: 无法读取文件 '{}': {}", cli.input, e);
            std::process::exit(1);
        }
    };

    // ------------------------------------------------------------------------
    // 执行转换
    // ------------------------------------------------------------------------
    let output_content = match convert(&input_content, from_format, to_format, cli.pretty) {
        Ok(content) => content,
        Err(e) => {
            eprintln!("错误: 转换失败: {}", e);
            std::process::exit(1);
        }
    };

    // ------------------------------------------------------------------------
    // 输出结果
    // ------------------------------------------------------------------------
    match &cli.output {
        Some(path) => {
            // 写入文件
            if let Err(e) = fs::write(path, &output_content) {
                eprintln!("错误: 无法写入文件 '{}': {}", path, e);
                std::process::exit(1);
            }
            if cli.verbose {
                println!("已写入: {}", path);
            }
        }
        None => {
            // 输出到标准输出
            println!("{}", output_content);
        }
    }
}

// ============================================================================
// 错误处理说明
// ============================================================================
//
// 本章使用简单的 match + eprintln! + exit(1) 模式处理错误
// 这是 CLI 程序常见的做法：
//
// 1. 检查操作结果
// 2. 如果失败，打印错误信息到 stderr
// 3. 以非零退出码退出
//
// 更高级的做法（后续章节会介绍）：
// - 使用 anyhow 或 thiserror 统一错误处理
// - 使用 ? 运算符简化代码
// - 定义自定义错误类型
