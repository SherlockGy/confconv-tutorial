//! confconv - 配置文件格式转换工具
//!
//! 第 1 章：最简单的 CLI 程序
//! 只接收一个位置参数：输入文件路径

use clap::Parser;

// ============================================================================
// CLI 结构体定义
// ============================================================================

/// 配置文件格式转换工具
///
/// 支持在 JSON、YAML、TOML 之间互相转换
// #[derive(Parser)] 是 clap 的核心宏
// 它会根据结构体字段自动生成参数解析代码
#[derive(Parser)]
// #[command(...)] 设置程序元数据
#[command(name = "confconv")]                    // 程序名（显示在帮助信息中）
#[command(version = "0.1.0")]                    // 版本号（--version 显示）
#[command(about = "配置文件格式转换工具")]         // 简短描述（帮助信息第一行）
struct Cli {
    /// 输入文件路径
    ///
    /// 支持 .json, .yaml, .yml, .toml 扩展名
    // 这是一个位置参数（positional argument）
    // 没有 #[arg(...)] 属性的 String 字段默认是必需的位置参数
    // 文档注释 /// 会成为帮助信息中的参数说明
    input: String,
}

// ============================================================================
// 程序入口
// ============================================================================

fn main() {
    // Cli::parse() 做了以下事情：
    // 1. 读取 std::env::args()
    // 2. 根据 Cli 结构体定义解析参数
    // 3. 如果参数错误，自动打印错误信息并退出（exit code 非 0）
    // 4. 如果遇到 --help 或 --version，打印相应信息并退出
    let cli = Cli::parse();

    // 目前只是打印收到的参数
    // 后续章节会添加真正的转换逻辑
    println!("输入文件: {}", cli.input);
    println!("\n功能开发中...");
}

// ============================================================================
// 与 Java 的对比说明
// ============================================================================
//
// Java 中，你可能这样处理命令行参数：
//
// ```java
// public static void main(String[] args) {
//     if (args.length < 1) {
//         System.out.println("用法: java App <input>");
//         System.exit(1);
//     }
//     String input = args[0];
// }
// ```
//
// 问题：
// - 需要手动检查参数数量
// - 需要手动打印用法信息
// - 容易忘记处理边界情况
//
// Clap 的优势：
// - 声明式定义，代码即文档
// - 自动生成帮助信息
// - 自动处理错误情况
// - 类型安全
